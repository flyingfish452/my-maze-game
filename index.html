<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Kitten Maze with Lives</title>
  <style>
    body { background-color: #222; color: #fff; font-family: sans-serif; text-align: center; }
    canvas { display: block; margin: 20px auto; border: 2px solid #fff; background: #000; }
    #score { font-size: 24px; margin-top: 10px; }
    #lives { font-size: 24px; margin-top: 10px; color: orange; }
    #message { display: none; font-size: 32px; color: lime; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>ðŸ˜º Kitten Maze 3D ðŸ˜º</h1>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <div id="score">Coins: 0</div>
  <div id="lives">Lives: 3</div>
  <div id="message">ðŸŽ‰ Well done! Loading new maze...</div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const CELL_SIZE = 40, MAZE_WIDTH = 15, MAZE_HEIGHT = 15, NUM_COINS = 10;
    const WALL_COLOR = "#888", PATH_COLOR = "#222", COIN_COLOR = "#FFD700";

    const DIRS = [[0, -1], [1, 0], [0, 1], [-1, 0]];

    let maze = [], coins = new Set();
    let catX = 1, catY = 1, targetX = 1, targetY = 1, animX = 1, animY = 1;
    let score = 0, isMoving = false, lives = 3;

    function resetGame() {
      maze = []; coins.clear();
      catX = 1; catY = 1; targetX = 1; targetY = 1; animX = 1; animY = 1; score = 0; isMoving = false; lives = 3;
      document.getElementById("message").style.display = "none";
      generateMaze(); placeCoins(); updateScore(); updateLives();
    }

    function generateMaze() {
      for (let y = 0; y < MAZE_HEIGHT; y++) {
        maze[y] = [];
        for (let x = 0; x < MAZE_WIDTH; x++) maze[y][x] = 1;
      }
      function carve(cx, cy) {
        maze[cy][cx] = 0;
        const directions = [...DIRS].sort(() => Math.random() - 0.5);
        for (let [dx, dy] of directions) {
          const nx = cx + dx * 2, ny = cy + dy * 2;
          if (nx >= 0 && nx < MAZE_WIDTH && ny >= 0 && ny < MAZE_HEIGHT && maze[ny][nx] === 1) {
            maze[cy + dy][cx + dx] = 0; carve(nx, ny);
          }
        }
      }
      carve(1, 1);
    }

    function placeCoins() {
      const freeCells = [];
      for (let y = 0; y < MAZE_HEIGHT; y++) for (let x = 0; x < MAZE_WIDTH; x++) if (maze[y][x] === 0 && !(x === 1 && y === 1)) freeCells.push([x, y]);
      freeCells.sort(() => Math.random() - 0.5);
      for (let i = 0; i < NUM_COINS && i < freeCells.length; i++) coins.add(freeCells[i].toString());
    }

    function drawMaze() {
      for (let y = 0; y < MAZE_HEIGHT; y++) for (let x = 0; x < MAZE_WIDTH; x++) {
        if (maze[y][x] === 1) {
          const gx = x * CELL_SIZE, gy = y * CELL_SIZE;
          ctx.fillStyle = WALL_COLOR;
          ctx.fillRect(gx, gy, CELL_SIZE, CELL_SIZE);
          ctx.fillStyle = "#444";
          ctx.fillRect(gx, gy + CELL_SIZE * 0.8, CELL_SIZE, CELL_SIZE * 0.2);
        } else {
          ctx.fillStyle = PATH_COLOR;
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    function drawCoins() {
      for (let pos of coins) {
        const [x, y] = pos.split(",").map(Number);
        const cx = x * CELL_SIZE + CELL_SIZE / 2, cy = y * CELL_SIZE + CELL_SIZE / 2;
        ctx.beginPath();
        ctx.arc(cx, cy, CELL_SIZE / 4, 0, Math.PI * 2);
        ctx.fillStyle = COIN_COLOR;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawCat(x, y) {
      const cx = x * CELL_SIZE + CELL_SIZE / 2, cy = y * CELL_SIZE + CELL_SIZE / 2;
      ctx.font = `${CELL_SIZE - 8}px sans-serif`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText("ðŸ˜º", cx, cy);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze(); drawCoins(); drawCat(animX, animY);
    }

    function updateScore() {
      document.getElementById("score").textContent = `Coins: ${score}`;
    }

    function updateLives() {
      document.getElementById("lives").textContent = `Lives: ${lives}`;
    }

    function checkWin() {
      if (coins.size === 0) {
        document.getElementById("message").textContent = "ðŸŽ‰ Well done! Loading new maze...";
        document.getElementById("message").style.display = "block";
        setTimeout(resetGame, 2000);
      }
    }

    function loseLife() {
      lives--;
      updateLives();
      if (lives <= 0) {
        document.getElementById("message").textContent = "ðŸ˜… Try again silly billy!";
        document.getElementById("message").style.display = "block";
        setTimeout(resetGame, 2000);
      }
    }

    function animate() {
      const speed = 0.2, dx = targetX - animX, dy = targetY - animY;
      if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) {
        animX = targetX; animY = targetY; isMoving = false;
      } else {
        animX += dx * speed; animY += dy * speed;
      }
      draw(); requestAnimationFrame(animate);
    }

    window.addEventListener("keydown", e => {
      if (isMoving) return;
      let nx = catX, ny = catY;
      if (e.key === "ArrowLeft") nx--; if (e.key === "ArrowRight") nx++; if (e.key === "ArrowUp") ny--; if (e.key === "ArrowDown") ny++;
      if (nx < 0 || nx >= MAZE_WIDTH || ny < 0 || ny >= MAZE_HEIGHT || maze[ny][nx] === 1) {
        loseLife();
        return;
      }
      const posKey = `${nx},${ny}`;
      catX = nx; catY = ny; targetX = nx; targetY = ny; isMoving = true;
      if (coins.has(posKey)) {
        coins.delete(posKey);
        score++;
        updateScore();
        checkWin();
      }
    });

    resetGame(); animate();
  </script>
</body>
</html>
